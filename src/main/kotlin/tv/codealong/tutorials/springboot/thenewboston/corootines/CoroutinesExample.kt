package tv.codealong.tutorials.springboot.thenewboston.corootines

import kotlinx.coroutines.*
import java.util.Random
import kotlin.system.measureTimeMillis

/**
 * https://www.youtube.com/watch?v=YD2GeSEJQtI&list=PL0SwNXKJbuNmsKQW9mtTSxNn00oJlYOLA&index=2
 *
 * Компилятор превращает код корутин в стейтмашину с множеством свитчкейсов, где каждый case соответствует
 * какому то вызову suspend функции.
 * Корутины не требуют системных ресурсов. Например, создание потока.
 * Поэтому их называют легковесными потоками.
 * Они используют умно заданные пулы потоков.
 * Каждая корутина привязана к времени жизни Scope.
 * Состояние корутин проверяют перед выполнением после того, как её прервали.
 * Т.е. перед вызовом любой suspend функции корутина может быть остановлена.
 *
 */
class CoroutinesExample {

}

/**
 * runBlocking - мостик между блокирующим миром и корутинами.
 * runBlocking нужно использовать или при запуске из main или при запуске для тестов.
 *
 * launch - Запускает новую сопрограмму, не блокируя текущий поток, и возвращает ссылку на сопрограмму как на Job.
 * Сопрограмма (корутина) отменяется, когда отменяется результирующее задание (Job).
 * Launch возвращает Job и позволяет управлять корутиной.
 * Запускаем корутины с помощью метода launch, и видим как суспенд функция будет выполняться в разных корутинах не по порядку. (быстро)
 * А если мы запустим doWork без оборачивания в launch, то эта функция будет просто выполняться по порядку 100 раз. (долго)
 *
 * Вместо launch можно использовать корутину async.
 * Async в отличие от launch возвращает результат Deferred (а не Job).
 */
fun main(): Unit = runBlocking {
    //запустим 100 корутин и увидим, что они выполняются не по порядку
    //Сохраним результат в список с Deferred
    //Deferred - это Отложенное значение - это не блокируемое будущее, которое можно отменить, это Job с определенным результатом.
    val coroutines: List<Deferred<String>> = List(100) {
        async(start = CoroutineStart.DEFAULT) { //По дефолту - корутина будет создана и сразу запущена, а когда для неё вызовется await() то отдает результат. Тут параллельное выполнение.
            //если мы хотим отменять корутины, то нужно проверять их статус
            //хотя это можно и не делать
            if (isActive) {
                doWork("Broadcast. #корутина: $it")
            } else {
                //нужно возвращать фейковое значение если есть проверка на isActive
                "---"
            }
        }
    }
    //отменим их с указанием опционального Exception или сообщения
    coroutines.forEach { println("отменяем корутину $it " + it.cancel()) }
}

//fun main(): Unit = runBlocking {
//    //запустим 100 корутин и увидим, что они выполняются не по порядку
//    //Сохраним результат в список с Job
//    //Job - Фоновое задание. По сути, Job - это объект, который можно отменить, с жизненным циклом, завершающимся завершением.
//    //Job могут быть организованы в иерархию "родитель-потомок", где отмена родительского элемента приводит к немедленной отмене всех его дочерних элементов рекурсивно.
//    val coroutines: List<Job> = List(100) {
//        launch(start = CoroutineStart.DEFAULT) { //По дефолту - корутина будет создана и сразу запущена, а когда для неё вызовется await() то отдает результат. Тут параллельное выполнение.
//            //если мы хотим отменять корутины, то нужно проверять их статус
//            if (isActive) {
//                doWork("Broadcast. #корутина: $it")
//            } else {
//                //нужно возвращать фейковое значение если есть проверка на isActive
//                "---"
//            }
//        }
//    }
//    //отменим их с указанием опционального Exception или сообщения
//    coroutines.forEach { println("отменяем корутину $it " + it.cancel("Отмена корутины!")) }
//}

//fun main(): Unit = runBlocking {
//    //запустим 100 корутин и увидим, что они выполняются не по порядку
//    //Сохраним результат в список с Deferred
//    //Deferred - это Отложенное значение - это не блокируемое будущее, которое можно отменить, это Job с определенным результатом.
//    val coroutines: List<Deferred<String>> = List(100) {
////        async(start = CoroutineStart.DEFAULT) { //По дефолту - корутина будет создана и сразу запущена а когда для неё вызовется await() то отдает результат. Тут параллельное выполнение.
//        async(start = CoroutineStart.LAZY) { //Lazy - корутина будет создана но запущена только когда для неё вызовется await(). Тут последовательное выполнение.
//            doWork("Broadcast. #корутина: $it")
//        }
//    }
//    //дождемся выполнения всех корутин (всех Job) и выведем результат
//    coroutines.forEach { println(it.await()) }
//}

//fun main(): Unit = runBlocking {
//    //запустим 100 корутин и увидим, что они выполняются не по порядку
//    repeat(100) {
//        launch {
//            val tookTime = measureTimeMillis {
//                val doWork = doWork("Broadcast. #корутина: $it")
//                println(doWork)
//            }
//            println("tookTime: $tookTime")
//        }
//    }
//}


/**
 * Эта функция выполняет какую-то работу. В неё можно передать название, которое
 * будет выведено, когда она выполниться.
 * Имитируем долгое выполнение с помощью delay (приостанавливает выполнение корутины).
 */
suspend fun doWork(name: String): String {
    val tookTime = measureTimeMillis {
        delay(Random().nextInt(5000).toLong())
    }
    return "Done. $name. Took time=$tookTime"
}