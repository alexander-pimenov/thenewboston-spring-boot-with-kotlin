Docker - best practice
{{1}}
--- Используй базовые образы с точными верстями пакетами и Операционных Систем
#Плохо
FROM python:3
#Хорошо
FROM python:3.11.5-slim-bookworm

{{2}}
--- Файл requirements.txt/poetry.lock с привязанными версиями
#Плохо
RUN python -m pip install django pands numpy
#Хорошо
COPY ./requirements.txt /requirements.txt
RUN python -m pip install -r requirements.txt
---------------------------------------------
# requirements.txt
django==4.2.1
numpy==1.25.2
pands==2.0.3

{{3}}
Количество слоев. Делай минимум слоев через объединение команд.
Каждая команда в DockerFile создает новый слой в Image.
И это увеличивает размер Image. Чтобы уменьшить количество слоёв
нужно объединять команды в цепочки.

#Плохо
# создали 2 слоя
RUN apt update
RUN apt -y install htop

#Хорошо
# создали 1 слой
RUN apt update && apt -y install htop

# или так создали 1 слой - вы великолепны
RUN apt update && apt -y install \
	htop \
	tree \
	mc

{{4}}
Нужно почистить образ от лишних данных
#Плохо 
Так мы создаем ещё один дополнительный слой без этих данных.
RUN rm -rf /usr/local/bundle/cache/*.pyc \
	&& apt-get clean \
	&& rm -rf /var/lib/apt/list/* /tmp/* /var/tmp/*
	
#Хорошо	
а так мы сразу почистим текущий слой
RUN curl -sL /usr/local/bundle/cache/*.pyc \
	&& apt-get -y install libpg-dev imagemagick gsfonts nodejs \
	&& bundle install --without development test --path vendor/bundle \
	&& rm -rf /usr/local/bundle/cache/*.pyc \
	&& apt-get clean \
	&& rm -rf /var/lib/apt/list/* /tmp/* /var/tmp/*
	
{{5}}
Используйте преимущество кэширования слоёв.
Чтобы ускорить сборку контейнера.
При запускке сборки Docker пытается использовать повторно слой 
из предыдущих запусков.
И если слой не изменился, то Docker берет слой из кэша сборки.
А если слой изменился, то этот слой и ВСЕ слой, которые идут после него,
должны быть заново созданы!!! И только предыдущие закэшируются.

#ПЛОХО
		LAYERS										Cache
FROM python:3.11.5-slim-bookword					V
WORKDIR /src										V
COPY . .											X
RUN python -m pip install -r requirements.txt		X
RUN что-то ещё										X
RUN что-то ещё										X
ENTRYPOINT [ "/bin/server" ]						X

Что бы увеличить количество слоёв, в которых ничего не изменяется, мы моежем
изменить их последовательность. Сначала поставить слой с загрузкой 
зависисмостей.И только потом копирование исходного кода в контейнер.

#ХОРОШО
		LAYERS										Cache
FROM python:3.11.5-slim-bookword					V
WORKDIR /src										V
COPY ./requirements.txt /requirements.txt			V
RUN python -m pip install -r requirements.txt		V
COPY . .											X
RUN что-то ещё										X
RUN что-то ещё										X
ENTRYPOINT [ "/bin/server" ]						X

Кэширование может привести к проблеме небезопасныйх образов,
это значит, что мы не будем получать обновление безопасности
для системных пакетов. Поэтому неоходимо пересобирать переодически образ
с нуля, чтобы обеспечить обновление систем безопасности.
Например, раз в месяц, пересобирать образ с помощью:

docker build --pull --no-cache

{{6}}
Не используйте ROOT.
По умолчанию контейнер Docker запускается от имени root.
Что представляет угрозу безопасности.

Нужно запускать update и upgrade от root, а потом нужно 
изменить пользователя на не root. И потом производим все действия
уже не от админ пользователя.

#ХОРОШО

FROM debian:booster
# запускаем от root
RUN apt-get update && apt-get -y upgrade

# меняем на не root
RUN useradd --create-home appuser
WORKDIR /home/appuser
USER appuser
ENTRYPOINT ["whoami"]

{{7}}
Используйте оптимизированные базовые образы.


{{8}}
Используйте мульти-стедж для уменьшения размера
и времени сборки контейнера.
Много-этапные (multi-stage builds) сборки.
Отделить стадию сборки от стадии выполнения.
Т.е. исключить лишние зависимости сборки из
образа. При этом оставиви их доступными во время
сборки образа за счет multi-stage.
Можно копировать необходимые ресурсы из одной стадии в 
другую, а значит лишние файлы остануться в промежуточной
сборке и не попадут в финальную.
Но делаем мы всё это в одном Dockerfile и это позволяет проводить
этапы сьорки параллельно.

# Dockerfile
# build stage
FROM buildbase as build
...
...
...

# production ready stage
FROM runbase
...
COPY --from=build
/artifact /app

Этот проет не оптимизирован, и весит много и работает не очень здорово.
#было
FROM python:3.11.5-slim-bookword

RUN curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.ru | python
ENV PATH /root/.poetry/bin:$PATH
WORKDIR /app
RUN python -m venv /app/venv
COPY pyproject.toml poetry.loc ./
RUN . /app/venv/bin/activate && poetry install
ENV PATH /app/venv/bin:$PATH
COPY . ./
CMD ["gunicorn", "blog.wsgi", "-b 0.0.0.0:8080", "--log-file", "-"]

Переписываем под мульти-стедж с двумя стадиями:
#стало
# 1 стадия - стадия зависимости и называем её venv
FROM python:3.11.5-slim-bookword
ENV PATH /app/venv/bin:$PATH
WORKDIR /app
COPY pyproject.toml poetry.loc ./
RUN python -m venv --copies /app/venv
RUN . /app/venv/bin/activate && poetry install

# 2 стадия, просто копируем собранные зависимости
FROM python:3.11.5-slim-bookword
# просто копируем уже готовую папку, которая была сделана в 1 стадии
COPY --from=venv /app/venv /app/venv
ENV PATH /app/venv/bin:$PATH
WORKDIR /app
COPY . ./
CMD ["gunicorn", "blog.wsgi", "-b 0.0.0.0:8080", "--log-file", "-"] 

Тут важно не сломать кэширование.


{{9}}
Используйте якоря [&] и псевдонимы [<<:*] для повторяющихся
блоков docker compose. Т.е. избавляемся от дублирования в docker compose.
якоря - yml функция, которая позволяет помечать элементы, а 
потом ссылаться на них в других местах файла.

version: "3.4"

services:
  web:
    build:
	  context: "."
	  args: 
	    - "APP_ENV=${APP_ENV:-prod}"
	depends_on:
	  - "postgres"
	  - "redis"
	env_file:
	  - ".env"
	image: "myapp"
	restart: "unless-stoped"
	stop_grace_period: "3s"
	volumes: 
	  - ".:/app"
	posts:
	  - "8003:8080"
  web2:
      web:
        build:
    	  context: "."
    	  args: 
    	    - "APP_ENV=${APP_ENV:-prod}"
    	depends_on:
    	  - "postgres"
    	  - "redis"
    	env_file:
    	  - ".env"
    	image: "myapp"
    	restart: "unless-stoped"
    	stop_grace_period: "3s"
    	volumes: 
    	  - ".:/app"
    	posts:
    	  - "8004:8080"

А тперь с использованием якоря:

version: "3.4"

services:
  web: &default-app
    build:
	  context: "."
	  args: 
	    - "APP_ENV=${APP_ENV:-prod}"
	depends_on:
	  - "postgres"
	  - "redis"
	env_file:
	  - ".env"
	image: "myapp"
	restart: "unless-stoped"
	stop_grace_period: "3s"
	volumes: 
	  - ".:/app"
	posts:
	  - "8003:8080"
  web2:
      <<: *default-app
      posts:
        - "8004:8080"
		
https://youtu.be/7Wx0R8YHfh8?t=649


 